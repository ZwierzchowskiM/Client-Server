====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\client\Client.java

package org.zwierzchowski.marcin.client;

import lombok.extern.log4j.Log4j2;

import java.io.IOException;
import java.util.Scanner;

@Log4j2
public class Client {

  private static final Scanner SCANNER = new Scanner(System.in);
  private static final String CLIENT_IP = "127.0.0.1";
  private static final int CLIENT_PORT = 6666;
  private final ClientNetworkHandler clientNetworkHandler = new ClientNetworkHandler();

  public static void main(String[] args) {
    Client client = new Client();
    client.communicateServer();
  }

  public Client() {
    try {
      clientNetworkHandler.connectToServer(CLIENT_IP, CLIENT_PORT);
    } catch (IOException e) {
      log.error("Failed to connect to server at {}:{}", CLIENT_IP, CLIENT_PORT, e);
      log.info("Application is shutting down...");
      System.exit(1);
    }
  }

  private void communicateServer() {
    while (!clientNetworkHandler.getSocket().isClosed()) {
      try {
        handleServerResponse();
        if (SCANNER.hasNextLine()) {
          String input = SCANNER.nextLine();
          handleUserInput(input);
        }
      } catch (IOException e) {
        log.error("Communication error", e);
      }
    }
  }

  private void handleServerResponse() throws IOException {
    do {
      String responseOpt = clientNetworkHandler.receiveResponse();
      clientNetworkHandler.printServerResponse(responseOpt);
    } while (clientNetworkHandler.hasResponse());
  }

  private void handleUserInput(String input) throws IOException {
    clientNetworkHandler.sendRequest(input);
    if (input.equalsIgnoreCase("stop")) {
      String responseOpt = clientNetworkHandler.receiveResponse();
      clientNetworkHandler.printServerResponse(responseOpt);
      clientNetworkHandler.closeConnection();
      SCANNER.close();
    }
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\client\ClientNetworkHandler.java

package org.zwierzchowski.marcin.client;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.Getter;
import lombok.extern.log4j.Log4j2;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;

@Log4j2
@Getter
public class ClientNetworkHandler {

  private Socket socket;
  private PrintWriter out;
  private BufferedReader in;
  private final ObjectMapper mapper = new ObjectMapper();

  public void connectToServer(String ip, int port) throws IOException {
    socket = new Socket(ip, port);
    out = new PrintWriter(socket.getOutputStream(), true);
    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
    log.info("Connected to server at {}:{}", ip, port);
  }

  public void sendRequest(String request) {
    out.println(request);
  }

  public String receiveResponse() throws IOException {
    return in.readLine();
  }

  public boolean hasResponse() throws IOException {
    return in.ready();
  }

  public void closeConnection() {
    try {
      socket.close();
    } catch (IOException e) {
      log.error("Error closing socket", e);
    }
    closeResources();
    log.info("Disconnected from server");
  }

  public void printServerResponse(String jsonResp) {
    try {
      JsonNode rootNode = mapper.readTree(jsonResp);
      String prettyString = rootNode.toPrettyString();
      log.info(prettyString);
    } catch (IOException e) {
      log.error("Error processing JSON response", e);
    }
  }

  private void closeResources() {
    try {
      if (out != null) {
        out.close();
      }
      if (in != null) {
        in.close();
      }
    } catch (IOException e) {
      log.error("Failed to close resources", e);
    }
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\exception\InvalidCredentialsFormatException.java

package org.zwierzchowski.marcin.exception;

public class InvalidCredentialsFormatException extends Exception {
    public InvalidCredentialsFormatException(String message) {
        super(message);
    }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\exception\InvalidMessageException.java

package org.zwierzchowski.marcin.exception;

public class InvalidMessageException extends Exception {
    public InvalidMessageException(String message) {
        super(message);
    }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\exception\InvalidPasswordException.java

package org.zwierzchowski.marcin.exception;

public class InvalidPasswordException extends Exception {

  public InvalidPasswordException(String message) {
    super(message);
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\exception\UserInboxIsFullException.java

package org.zwierzchowski.marcin.exception;

public class UserInboxIsFullException extends Exception {
  private String username;

  public UserInboxIsFullException(String message, String username) {
    super(message);
    this.username = username;
  }

  @Override
  public String getMessage() {
    return "Recipient '" + username + "' inbox is full";
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\exception\UserNotFoundException.java

package org.zwierzchowski.marcin.exception;

public class UserNotFoundException extends Exception {
    private String username;

    public UserNotFoundException(String message, String username) {
        super(message);
        this.username = username;
    }

    @Override
    public String getMessage() {
        return "User '" + username + "' not found";
    }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\message\Message.java

package org.zwierzchowski.marcin.message;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;
import java.util.Date;

@Getter
@Setter
public class Message {

  @JsonProperty("content")
  private String content;

  @JsonProperty("sender")
  private String sender;

  @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd@HH:mm:ss")
  private Date createdDate;

  @JsonProperty("status")
  private Status status;

  @JsonCreator
  public Message(@JsonProperty("content") String content, @JsonProperty("sender") String sender) {
    this.content = content;
    this.sender = sender;
    this.createdDate = Date.from(Instant.now());
    this.status = Status.UNREAD;
  }

  public enum Status {
    READ,
    UNREAD
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\message\MessageService.java

package org.zwierzchowski.marcin.message;

import org.zwierzchowski.marcin.exception.UserInboxIsFullException;
import org.zwierzchowski.marcin.exception.UserNotFoundException;
import org.zwierzchowski.marcin.user.User;
import org.zwierzchowski.marcin.utils.FileService;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class MessageService {

  private static final int MAX_UNREAD_MESSAGES = 4;

  public void sendMessage(String recipient, String content, String sender)
      throws UserNotFoundException, UserInboxIsFullException, IOException {
    Message message = new Message(content, sender);
    Map<String, User> users = FileService.loadDataBase();

    if (!users.containsKey(recipient)) {
      throw new UserNotFoundException("Recipient not found", recipient);
    }

    User user = users.get(recipient);

    if (checkUserInboxIsFull(user.getMessages())) {
      throw new UserInboxIsFullException("Recipient inbox is full", recipient);
    }

    user.addMessage(message);
    FileService.saveDataBase(users);
  }

  public List<Message> getUnreadMessages(String username)
      throws IOException, UserNotFoundException {

    Map<String, User> users = FileService.loadDataBase();
    if (!users.containsKey(username)) {
      throw new UserNotFoundException("Recipient not found", username);
    }
    User user = users.get(username);
    List<Message> messages = user.getMessages();
    List<Message> unreadMessages = new ArrayList<>();
    if (!messages.isEmpty()) {
      for (Message m : messages) {
        if (m.getStatus().equals(Message.Status.UNREAD)) {
          unreadMessages.add(m);
          m.setStatus(Message.Status.READ);
        }
      }
    }

    FileService.saveDataBase(users);
    return unreadMessages;
  }

  private boolean checkUserInboxIsFull(List<Message> messages) {
    long countUnread =
        messages.stream().filter(m -> m.getStatus().equals(Message.Status.UNREAD)).count();
    return countUnread > MAX_UNREAD_MESSAGES;
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\server\Server.java

package org.zwierzchowski.marcin.server;

import com.fasterxml.jackson.core.JsonProcessingException;
import lombok.extern.log4j.Log4j2;
import org.zwierzchowski.marcin.message.Message;
import org.zwierzchowski.marcin.message.MessageService;
import org.zwierzchowski.marcin.user.User;
import org.zwierzchowski.marcin.user.UserDataService;
import org.zwierzchowski.marcin.utils.CredentialsValidator;
import org.zwierzchowski.marcin.utils.MessageValidator;

import java.io.IOException;
import java.net.ServerSocket;
import java.time.Instant;
import java.util.List;

@Log4j2
public class Server {

  private ServerSocket serverSocket;
  private ServerData serverData;
  private ServerCommandService serverCommandService;
  private Session session = new Session();
  private ServerResponse response = new ServerResponse();
  private ServerNetworkHandler serverNetworkHandler;

  public Server(int port) {
    try {
      serverSocket = new ServerSocket(port);
    } catch (IOException e) {
      log.error("Error creating server", e);
      log.info("Application is shutting down...");
      System.exit(1);
    }
    serverData = new ServerData();
    serverNetworkHandler = new ServerNetworkHandler(serverSocket);
    serverCommandService = new ServerCommandService(serverNetworkHandler, session, serverData);
    log.info("Server started on port {}", port);
  }

  public static void main(String[] args) {
    Server server = new Server(6666);
    server.start();
  }

  public void start() {
    try {
      serverNetworkHandler.acceptConnection();
    } catch (IOException e) {
      log.error("Failed to connect client", e);
      System.exit(1);
    }
    handleClient();
  }

  private void handleClient() {
    try {
      String clientRequest;
      serverNetworkHandler.sendMessage(serverCommandService.printOptions());

      while ((clientRequest = serverNetworkHandler.receiveMessage()) != null) {
        log.info("Client request: {}", clientRequest);

        String serverResponse = serverCommandService.handleRequest(clientRequest);
        if ("STOP_SERVER".equals(serverResponse)) {
          break;
        }
        serverNetworkHandler.sendMessage(serverResponse);
        serverNetworkHandler.sendMessage(serverCommandService.printOptions());
      }
    } catch (IOException e) {
      log.error("Error handling client", e);
    } finally {
      serverNetworkHandler.close();
    }
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\server\ServerCommandService.java

package org.zwierzchowski.marcin.server;

import static org.zwierzchowski.marcin.server.ServerCommandService.Command.*;

import com.fasterxml.jackson.core.JsonProcessingException;
import java.io.IOException;
import java.util.List;
import lombok.extern.log4j.Log4j2;
import org.zwierzchowski.marcin.exception.*;
import org.zwierzchowski.marcin.message.Message;
import org.zwierzchowski.marcin.message.MessageService;
import org.zwierzchowski.marcin.user.User;
import org.zwierzchowski.marcin.user.UserDataService;
import org.zwierzchowski.marcin.utils.CredentialsValidator;
import org.zwierzchowski.marcin.utils.MessageValidator;

@Log4j2
public class ServerCommandService {

  private UserDataService userDataService = new UserDataService();
  private MessageService messageService = new MessageService();
  private ServerResponse response = new ServerResponse();
  private ServerNetworkHandler serverNetworkHandler;
  private Session session;
  private ServerData serverData;

  public ServerCommandService(
      ServerNetworkHandler serverNetworkHandler, Session session, ServerData serverData) {
    this.serverNetworkHandler = serverNetworkHandler;
    this.session = session;
    this.serverData = serverData;
  }

  public String handleRequest(String clientRequest) throws JsonProcessingException {

    Command command = fromString(clientRequest);
    try {
      return switch (command) {
        case REGISTER -> handleRegistration();
        case LOGIN -> handleUserLogin();
        case LOGOUT -> handleUserLogout();
        case DELETE -> handleUserDelete();
        case SEND -> handleSendMessage();
        case READ -> handleReadMessages();
        case STOP -> handleStopServer();
        case UPTIME -> response.calculateUptime(serverData.getStartTime());
        case HELP -> response.printServerCommands(serverData.getCommandsInfo());
        case INFO -> response.printServerInfo(serverData.getSeverInfo());
        case UNKNOWN -> response.printText("Command unknown");
      };
    } catch (JsonProcessingException e) {
      log.error("JSON processing error", e);
      return response.printError(e.getMessage());
    } catch (IOException e) {
      log.error("IO error", e);
      return response.printError(e.getMessage());
    } catch (InvalidCredentialsFormatException e) {
      log.error("Invalid Credentials format", e);
      return response.printError(e.getMessage());
    } catch (UserNotFoundException | InvalidPasswordException e) {
      log.error("Invalid user credentials", e);
      return response.printError(e.getMessage());
    }
  }

  private String handleRegistration() throws IOException, InvalidCredentialsFormatException {
    serverNetworkHandler.sendMessage(response.printText("Please provide username"));
    String username = serverNetworkHandler.receiveMessage();
    CredentialsValidator.validateUsername(username);

    serverNetworkHandler.sendMessage(response.printText("Please provide password"));
    String password = serverNetworkHandler.receiveMessage();
    CredentialsValidator.validatePassword(password);

    serverNetworkHandler.sendMessage(response.printText("Please provide user role"));
    String role = serverNetworkHandler.receiveMessage();
    CredentialsValidator.validateRole(role);

    User user = userDataService.addUser(username, password, role);

    return response.printText("User: " + user.getUsername() + " successfully registered");
  }

  private String handleUserLogin()
      throws IOException, UserNotFoundException, InvalidPasswordException {
    serverNetworkHandler.sendMessage(response.printText("Please provide username"));
    String username = serverNetworkHandler.receiveMessage();

    serverNetworkHandler.sendMessage(response.printText("Please provide password"));
    String password = serverNetworkHandler.receiveMessage();

    userDataService.isValidCredentials(username, password);
    User user = userDataService.getUser(username);
    session.setLoggedInUser(user);
    return response.printLoginStatus(true);
  }

  private String handleStopServer() throws JsonProcessingException {
    serverNetworkHandler.sendMessage(response.printText("Shutting down server"));
    return "STOP_SERVER";
  }

  private String handleUserLogout() throws JsonProcessingException {
    if (!session.isUserLoggedIn()) {
      return response.printText("No user logged in");
    }
    session.logoutUser();
    return response.printText("Logout successful");
  }

  private String handleUserDelete() throws IOException, UserNotFoundException {

    if (!session.isAdminLoggedIn()) {
      return response.printText("Admin privileges are required to delete a user.");
    }
    serverNetworkHandler.sendMessage(response.printText("Please provide username"));
    String username = serverNetworkHandler.receiveMessage();

    userDataService.deleteUser(username);
    return response.printText("User successfully deleted");
  }

  private String handleSendMessage() throws JsonProcessingException {

    try {
      if (!session.isUserLoggedIn()) {
        return response.printText("User needs to log in");
      }
      serverNetworkHandler.sendMessage(response.printText("Please provide recipient"));
      String recipient = serverNetworkHandler.receiveMessage();

      serverNetworkHandler.sendMessage(response.printText("Please provide  message"));
      String content = serverNetworkHandler.receiveMessage();

      MessageValidator.validateMessage(content);
      String sender = session.getLoggedInUser().getUsername();
      messageService.sendMessage(recipient, content, sender);
      return response.printText("Message to send successfully");
    } catch (IOException e) {
      log.error("Error while communicating with server", e);
      return response.printText("Error while communicating with server: " + e.getMessage());
    } catch (InvalidMessageException e) {
      log.error("Invalid Message format", e);
      return response.printText("Invalid message: " + e.getMessage());
    } catch (UserNotFoundException e) {
      log.error("User not found", e);
      return response.printText("Recipient not found: " + e.getMessage());
    } catch (UserInboxIsFullException e) {
      log.error("User inbox is full", e);
      return response.printText("Message not send." + e.getMessage());
    }
  }

  private String handleReadMessages() throws IOException {
    try {
      if (!session.isUserLoggedIn()) {
        return response.printText("User needs to log in");
      }
      User user = session.getLoggedInUser();
      List<Message> unreadMessages = messageService.getUnreadMessages(user.getUsername());
      if (unreadMessages.isEmpty()) {
        return response.printText("No unread messages");
      }
      return response.printUnreadMessages(unreadMessages);
    } catch (UserNotFoundException e) {
      log.error("User not found", e);
      return response.printText("Recipient not found: " + e.getMessage());
    }
  }

  public String printOptions() throws JsonProcessingException {
    if (session.isUserLoggedIn()) {
      return printUserOptions();
    } else if (session.isAdminLoggedIn()) {
      return printAdminOptions();
    } else return printWelcomeOptions();
  }

  private String printWelcomeOptions() throws JsonProcessingException {

    StringBuilder options = new StringBuilder();
    options.append("Type command: ").append("LOGIN,").append("REGISTER.");
    return response.printText(options.toString());
  }

  private String printAdminOptions() throws JsonProcessingException {
    StringBuilder options = new StringBuilder();
    options
        .append("Type command: ")
        .append("SEND, ")
        .append("READ, ")
        .append("DELETE, ")
        .append("HELP, ")
        .append("LOGOUT.");
    return response.printText(options.toString());
  }

  private String printUserOptions() throws JsonProcessingException {
    StringBuilder options = new StringBuilder();
    options
        .append("Type command: ")
        .append("SEND, ")
        .append("READ, ")
        .append("HELP, ")
        .append("LOGOUT.");
    return response.printText(options.toString());
  }

  public enum Command {
    REGISTER,
    LOGIN,
    LOGOUT,
    DELETE,
    SEND,
    READ,
    UPTIME,
    HELP,
    INFO,
    STOP,
    UNKNOWN;

    public static Command fromString(String command) {
      try {
        return Command.valueOf(command.toUpperCase());
      } catch (IllegalArgumentException e) {
        return UNKNOWN;
      }
    }
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\server\ServerData.java

package org.zwierzchowski.marcin.server;

import lombok.Getter;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

@Getter
public class ServerData {

  private final Map<String, String> commandsInfo = new HashMap<>();
  private final Map<String, String> severInfo = new HashMap<>();
  private static final String SERVER_VERSION = "0.2.0";
  private static final String SERVER_CREATION_DATE = "19.04.2024";
  private Instant startTime;

  public ServerData() {
    initialize();
  }

  private void initialize() {
    commandsInfo.put("uptime", "Returns the server's uptime");
    commandsInfo.put("info", "Returns the server's version number and creation date");
    commandsInfo.put("help", "Returns a list of available commands with a brief description");
    commandsInfo.put("stop", "stops both the server and the client simultaneously");
    commandsInfo.put("register", "Add new user");
    commandsInfo.put("login", "Login existing user");
    commandsInfo.put("logout", "Logout user");
    commandsInfo.put("delete", "Delete existing user. Required admin role");
    commandsInfo.put("send", "Send message to another user");
    commandsInfo.put("read", "Read unread messages in inbox");

    severInfo.put("version", SERVER_VERSION);
    severInfo.put("creation date", SERVER_CREATION_DATE);

    startTime = Instant.now();
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\server\ServerNetworkHandler.java

package org.zwierzchowski.marcin.server;

import lombok.extern.log4j.Log4j2;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

@Log4j2
public class ServerNetworkHandler {

  private Socket clientSocket;
  private BufferedReader in;
  private PrintWriter out;
  private ServerSocket serverSocket;

  public ServerNetworkHandler(ServerSocket serverSocket) {
    this.serverSocket = serverSocket;
  }

  public void acceptConnection() throws IOException {

    log.info("Waiting for a client...");
    clientSocket = serverSocket.accept();
    in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
    out = new PrintWriter(clientSocket.getOutputStream(), true);
    log.info("Client connected");
  }

  public String receiveMessage() throws IOException {
    return in.readLine();
  }

  public void sendMessage(String message) {
    out.println(message);
  }

  public void close() {
    closeClientConnection();
    closeServerSocket();
  }

  private void closeClientConnection() {
    log.info("Closing client connection...");
    try {
      if (out != null) {
        out.close();
      }
      if (in != null) {
        in.close();
      }
      if (clientSocket != null && !clientSocket.isClosed()) {
        clientSocket.close();
      }
    } catch (IOException e) {
      log.error("Failed to close client connection resources: {}", e.getMessage());
    }
  }

  private void closeServerSocket() {
    log.info("Closing server socket...");
    try {
      if (serverSocket != null && !serverSocket.isClosed()) {
        serverSocket.close();
      }
    } catch (IOException e) {
      log.error("Error closing server socket: {}", e.getMessage());
    }
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\server\ServerResponse.java

package org.zwierzchowski.marcin.server;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import org.zwierzchowski.marcin.message.Message;
import org.zwierzchowski.marcin.user.User;

import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class ServerResponse {

  private ObjectMapper mapper = new ObjectMapper();

  public String calculateUptime(Instant startTime) throws JsonProcessingException {
    Duration serverUptime = Duration.between(startTime, Instant.now());
    Map<String, Integer> uptimeResponse = new HashMap<>();
    uptimeResponse.put("hours", serverUptime.toHoursPart());
    uptimeResponse.put("minutes", serverUptime.toMinutesPart());
    uptimeResponse.put("seconds", serverUptime.toSecondsPart());
    return mapper.writeValueAsString(uptimeResponse);
  }

  public String printServerCommands(Map<String, String> commandsInfo)
      throws JsonProcessingException {
    return mapper.writeValueAsString(commandsInfo);
  }

  public String printServerInfo(Map<String, String> serverInfo) throws JsonProcessingException {
    return mapper.writeValueAsString(serverInfo);
  }

  public String printText(String text) throws JsonProcessingException {
    return mapper.writeValueAsString(text);
  }

  public String printError(String text) throws JsonProcessingException {
    Map<String, String> message = new HashMap<>();
    message.put("error", text);
    return mapper.writeValueAsString(message);
  }

  public String printLoginStatus(boolean status) throws JsonProcessingException {
    Map<String, String> response = new HashMap<>();
    if (status) {
      response.put("status", "success");
      response.put("message", "User sucessfully logged in");
    } else {
      response.put("status", "failure");
      response.put("message", "Incorrect username or password");
    }
    return mapper.writeValueAsString(response);
  }

  public String printUnreadMessages(List<Message> unreadMessages) throws JsonProcessingException {
    Map<String, Message> messagesResponse = new LinkedHashMap<>();
    for (int i = 0; i < unreadMessages.size(); i++) {
      Message m = unreadMessages.get(i);
      messagesResponse.put("Message " + (i + 1), m);
    }
    return mapper.writeValueAsString(messagesResponse);
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\server\Session.java

package org.zwierzchowski.marcin.server;

import lombok.Getter;
import lombok.Setter;
import org.zwierzchowski.marcin.user.User;

@Getter
@Setter
public class Session {

  private User loggedInUser;

  public boolean isUserLoggedIn() {
    return loggedInUser != null;
  }

  public boolean isAdminLoggedIn() {
    return loggedInUser != null && loggedInUser.getRole().equals(User.Role.ADMIN);
  }

  public void logoutUser() {
    loggedInUser = null;
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\user\Admin.java

package org.zwierzchowski.marcin.user;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonTypeName;
import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;

@Getter
@Setter
@JsonTypeName("admin")
public class Admin extends User {
  @JsonCreator
  public Admin(
      @JsonProperty("username") String username, @JsonProperty("password") String password) {
    super(username, password, Role.ADMIN, new ArrayList<>());
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\user\StandardUser.java

package org.zwierzchowski.marcin.user;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonTypeName;
import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;

@Getter
@Setter
@JsonTypeName("user")
public class StandardUser extends User {

  @JsonCreator
  public StandardUser(
      @JsonProperty("username") String username, @JsonProperty("password") String password) {
    super(username, password, Role.USER, new ArrayList<>());
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\user\User.java

package org.zwierzchowski.marcin.user;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import org.zwierzchowski.marcin.message.Message;
import java.util.List;

import static com.fasterxml.jackson.annotation.JsonTypeInfo.As.PROPERTY;

@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = PROPERTY, property = "type")
@JsonSubTypes({
  @JsonSubTypes.Type(value = Admin.class, name = "admin"),
  @JsonSubTypes.Type(value = StandardUser.class, name = "user")
})
@Getter
@Setter
@AllArgsConstructor
public abstract class User {

  @JsonProperty("username")
  private String username;

  @JsonProperty("password")
  private String password;

  @Setter(AccessLevel.NONE)
  @JsonProperty("role")
  private Role role;

  @JsonProperty("messages")
  private List<Message> messages;

  public enum Role {
    USER,
    ADMIN
  }

  public void addMessage(Message message) {
    messages.add(message);
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\user\UserDataService.java

package org.zwierzchowski.marcin.user;

import org.mindrot.jbcrypt.BCrypt;
import org.zwierzchowski.marcin.exception.InvalidCredentialsFormatException;
import org.zwierzchowski.marcin.exception.InvalidPasswordException;
import org.zwierzchowski.marcin.exception.UserNotFoundException;
import org.zwierzchowski.marcin.utils.FileService;

import java.io.IOException;
import java.util.Map;

public class UserDataService {

  public User addUser(String username, String password, String role)
      throws IOException, InvalidCredentialsFormatException {
    Map<String, User> users = FileService.loadDataBase();
    String hashedPassword = BCrypt.hashpw(password, BCrypt.gensalt());
    User newUser =
        switch (role.toLowerCase()) {
          case "user" -> new StandardUser(username, hashedPassword);
          case "admin" -> new Admin(username, hashedPassword);
          default -> throw new InvalidCredentialsFormatException("Unexpected value: " + role);
        };

    users.put(username, newUser);
    FileService.saveDataBase(users);
    return newUser;
  }

  public boolean isValidCredentials(String username, String password)
      throws IOException, UserNotFoundException, InvalidPasswordException {
    Map<String, User> users = FileService.loadDataBase();
    if (!users.containsKey(username)) {
      throw new UserNotFoundException("User not exist", username);
    }

    User user = users.get(username);
    if (!BCrypt.checkpw(password, user.getPassword())) {
      throw new InvalidPasswordException("Invalid password");
    }

    return true;
  }

  public User getUser(String username) throws IOException, UserNotFoundException {
    Map<String, User> users = FileService.loadDataBase();
    User user = users.get(username);
    if (user == null) {
      throw new UserNotFoundException("User not find:", username);
    }
    return user;
  }

  public void deleteUser(String username) throws IOException, UserNotFoundException {

    Map<String, User> users = FileService.loadDataBase();
    if (users.containsKey(username)) {
      users.remove(username);
      FileService.saveDataBase(users);
    } else {
      throw new UserNotFoundException("User not found", username);
    }
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\utils\CredentialsValidator.java

package org.zwierzchowski.marcin.utils;

import org.zwierzchowski.marcin.exception.InvalidCredentialsFormatException;
import org.zwierzchowski.marcin.user.User;

import java.util.regex.Pattern;

public class CredentialsValidator {

  private static final String USERNAME_PATTERN = "^[A-Za-z][A-Za-z0-9]{1,28}$";
  private static final String PASSWORD_PATTERN = "^[A-Za-z]\\w{2,29}$";

  private CredentialsValidator() {}

  public static void validateUsername(String username) throws InvalidCredentialsFormatException {
    if (!Pattern.matches(USERNAME_PATTERN, username)) {
      throw new InvalidCredentialsFormatException("Invalid username format");
    }
  }

  public static void validatePassword(String password) throws InvalidCredentialsFormatException {
    if (!Pattern.matches(PASSWORD_PATTERN, password)) {
      throw new InvalidCredentialsFormatException("Invalid password format");
    }
  }

  public static void validateRole(String role) throws InvalidCredentialsFormatException {
    boolean isValidRole = false;
    for (User.Role r : User.Role.values()) {
      if (r.name().equalsIgnoreCase(role)) {
        isValidRole = true;
        break;
      }
    }
    if (!isValidRole) {
      throw new InvalidCredentialsFormatException("Invalid role");
    }
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\utils\FileService.java

package org.zwierzchowski.marcin.utils;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import org.zwierzchowski.marcin.user.User;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class FileService {

  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
  private static final String FILE_PATH = "./users.json";

  private FileService() {}

  public static Map<String, User> loadDataBase() throws IOException {
    File file = new File(FILE_PATH);
    if (file.exists() && file.length() != 0) {
      return OBJECT_MAPPER.readValue(file, new TypeReference<Map<String, User>>() {});
    } else {
      return new HashMap<>();
    }
  }

  public static void saveDataBase(Map<String, User> users) throws IOException {
    File file = new File(FILE_PATH);
    OBJECT_MAPPER.enable(SerializationFeature.INDENT_OUTPUT);
    OBJECT_MAPPER.writerFor(new TypeReference<Map<String, User>>() {}).writeValue(file, users);
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\utils\MessageValidator.java

package org.zwierzchowski.marcin.utils;

import org.zwierzchowski.marcin.exception.InvalidMessageException;

public class MessageValidator {

  private static final int MESSAGE_LENGTH = 255;

  private MessageValidator() {}

  public static void validateMessage(String content) throws InvalidMessageException {
    if (content == null || content.length()  > MESSAGE_LENGTH || content.isEmpty()) {
      throw new InvalidMessageException("Invalid message format");
    }
  }
}
====================

