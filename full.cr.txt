====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\client\Client.java

package org.zwierzchowski.marcin.client;

import lombok.extern.log4j.Log4j2;

import java.io.IOException;
import java.util.Scanner;

@Log4j2
public class Client {

  private static final Scanner SCANNER = new Scanner(System.in);
  private static final String CLIENT_IP = "127.0.0.1";
  private static final int CLIENT_PORT = 6666;
  private final ClientNetworkHandler clientNetworkHandler = new ClientNetworkHandler();

  public static void main(String[] args) {
    Client client = new Client();
    client.communicateServer();
  }

  public Client() {
    try {
      clientNetworkHandler.connectToServer(CLIENT_IP, CLIENT_PORT);
    } catch (IOException e) {
      log.error("Failed to connect to server at {}:{}", CLIENT_IP, CLIENT_PORT, e);
      log.info("Application is shutting down...");
      System.exit(1);
    }
  }

  private void communicateServer() {
    while (!clientNetworkHandler.getSocket().isClosed()) {
      try {
        handleServerResponse();
        if (SCANNER.hasNextLine()) {
          String input = SCANNER.nextLine();
          handleUserInput(input);
        }
      } catch (IOException e) {
        log.error("Communication error", e);
      }
    }
  }

  private void handleServerResponse() throws IOException {
    do {
      String serverResponse = clientNetworkHandler.receiveResponse();
      clientNetworkHandler.printServerResponse(serverResponse);
    } while (clientNetworkHandler.hasResponse());
  }

  private void handleUserInput(String input) throws IOException {
    clientNetworkHandler.sendRequest(input);
    if (input.equalsIgnoreCase("stop")) {
      String responseOpt = clientNetworkHandler.receiveResponse();
      clientNetworkHandler.printServerResponse(responseOpt);
      clientNetworkHandler.closeConnection();
      SCANNER.close();
    }
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\client\ClientNetworkHandler.java

package org.zwierzchowski.marcin.client;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.Getter;
import lombok.extern.log4j.Log4j2;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;

@Log4j2
@Getter
public class ClientNetworkHandler {

  private Socket socket;
  private PrintWriter out;
  private BufferedReader in;
  private final ObjectMapper mapper = new ObjectMapper();

  public void connectToServer(String ip, int port) throws IOException {
    socket = new Socket(ip, port);
    out = new PrintWriter(socket.getOutputStream(), true);
    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
    log.info("Connected to server at {}:{}", ip, port);
  }

  public void sendRequest(String request) {
    out.println(request);
  }

  public String receiveResponse() throws IOException {
    return in.readLine();
  }

  public boolean hasResponse() throws IOException {
    return in.ready();
  }

  public void closeConnection() {
    try {
      socket.close();
    } catch (IOException e) {
      log.error("Error closing socket", e);
    }
    closeResources();
    log.info("Disconnected from server");
  }

  public void printServerResponse(String jsonResp) {
    try {
      JsonNode rootNode = mapper.readTree(jsonResp);
      String prettyString = rootNode.toPrettyString();
      log.info(prettyString);
    } catch (IOException e) {
      log.error("Error processing JSON response", e);
    }
  }

  private void closeResources() {
    try {
      if (out != null) {
        out.close();
      }
      if (in != null) {
        in.close();
      }
    } catch (IOException e) {
      log.error("Failed to close resources", e);
    }
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\db\DefaultCatalog.java

/*
 * This file is generated by jOOQ.
 */
package org.zwierzchowski.marcin.db;


import java.util.Arrays;
import java.util.List;

import org.jooq.Constants;
import org.jooq.Schema;
import org.jooq.impl.CatalogImpl;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class DefaultCatalog extends CatalogImpl {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>DEFAULT_CATALOG</code>
     */
    public static final DefaultCatalog DEFAULT_CATALOG = new DefaultCatalog();

    /**
     * The schema <code>public</code>.
     */
    public final Public PUBLIC = Public.PUBLIC;

    /**
     * No further instances allowed
     */
    private DefaultCatalog() {
        super("");
    }

    @Override
    public final List<Schema> getSchemas() {
        return Arrays.asList(
            Public.PUBLIC
        );
    }

    /**
     * A reference to the 3.19 minor release of the code generator. If this
     * doesn't compile, it's because the runtime library uses an older minor
     * release, namely: 3.19. You can turn off the generation of this reference
     * by specifying /configuration/generator/generate/jooqVersionReference
     */
    private static final String REQUIRE_RUNTIME_JOOQ_VERSION = Constants.VERSION_3_19;
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\db\Keys.java

/*
 * This file is generated by jOOQ.
 */
package org.zwierzchowski.marcin.db;


import org.jooq.ForeignKey;
import org.jooq.TableField;
import org.jooq.UniqueKey;
import org.jooq.impl.DSL;
import org.jooq.impl.Internal;
import org.zwierzchowski.marcin.db.tables.Messages;
import org.zwierzchowski.marcin.db.tables.Users;
import org.zwierzchowski.marcin.db.tables.records.MessagesRecord;
import org.zwierzchowski.marcin.db.tables.records.UsersRecord;


/**
 * A class modelling foreign key relationships and constraints of tables in
 * public.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class Keys {

    // -------------------------------------------------------------------------
    // UNIQUE and PRIMARY KEY definitions
    // -------------------------------------------------------------------------

    public static final UniqueKey<MessagesRecord> MESSAGES_PKEY = Internal.createUniqueKey(Messages.MESSAGES, DSL.name("messages_pkey"), new TableField[] { Messages.MESSAGES.ID }, true);
    public static final UniqueKey<UsersRecord> USERS_PKEY = Internal.createUniqueKey(Users.USERS, DSL.name("users_pkey"), new TableField[] { Users.USERS.ID }, true);

    // -------------------------------------------------------------------------
    // FOREIGN KEY definitions
    // -------------------------------------------------------------------------

    public static final ForeignKey<MessagesRecord, UsersRecord> MESSAGES__FK_USER = Internal.createForeignKey(Messages.MESSAGES, DSL.name("fk_user"), new TableField[] { Messages.MESSAGES.USER_ID }, Keys.USERS_PKEY, new TableField[] { Users.USERS.ID }, true);
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\db\Public.java

/*
 * This file is generated by jOOQ.
 */
package org.zwierzchowski.marcin.db;


import java.util.Arrays;
import java.util.List;

import org.jooq.Catalog;
import org.jooq.Table;
import org.jooq.impl.SchemaImpl;
import org.zwierzchowski.marcin.db.tables.Messages;
import org.zwierzchowski.marcin.db.tables.Users;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class Public extends SchemaImpl {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>public</code>
     */
    public static final Public PUBLIC = new Public();

    /**
     * The table <code>public.messages</code>.
     */
    public final Messages MESSAGES = Messages.MESSAGES;

    /**
     * The table <code>public.users</code>.
     */
    public final Users USERS = Users.USERS;

    /**
     * No further instances allowed
     */
    private Public() {
        super("public", null);
    }


    @Override
    public Catalog getCatalog() {
        return DefaultCatalog.DEFAULT_CATALOG;
    }

    @Override
    public final List<Table<?>> getTables() {
        return Arrays.asList(
            Messages.MESSAGES,
            Users.USERS
        );
    }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\db\tables\Messages.java

/*
 * This file is generated by jOOQ.
 */
package org.zwierzchowski.marcin.db.tables;


import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

import org.jooq.Condition;
import org.jooq.Field;
import org.jooq.ForeignKey;
import org.jooq.Identity;
import org.jooq.InverseForeignKey;
import org.jooq.Name;
import org.jooq.Path;
import org.jooq.PlainSQL;
import org.jooq.QueryPart;
import org.jooq.Record;
import org.jooq.SQL;
import org.jooq.Schema;
import org.jooq.Select;
import org.jooq.Stringly;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.TableOptions;
import org.jooq.UniqueKey;
import org.jooq.impl.DSL;
import org.jooq.impl.SQLDataType;
import org.jooq.impl.TableImpl;
import org.zwierzchowski.marcin.db.Keys;
import org.zwierzchowski.marcin.db.Public;
import org.zwierzchowski.marcin.db.tables.Users.UsersPath;
import org.zwierzchowski.marcin.db.tables.records.MessagesRecord;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class Messages extends TableImpl<MessagesRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>public.messages</code>
     */
    public static final Messages MESSAGES = new Messages();

    /**
     * The class holding records for this type
     */
    @Override
    public Class<MessagesRecord> getRecordType() {
        return MessagesRecord.class;
    }

    /**
     * The column <code>public.messages.user_id</code>.
     */
    public final TableField<MessagesRecord, Integer> USER_ID = createField(DSL.name("user_id"), SQLDataType.INTEGER, this, "");

    /**
     * The column <code>public.messages.content</code>.
     */
    public final TableField<MessagesRecord, String> CONTENT = createField(DSL.name("content"), SQLDataType.VARCHAR(255), this, "");

    /**
     * The column <code>public.messages.sender</code>.
     */
    public final TableField<MessagesRecord, String> SENDER = createField(DSL.name("sender"), SQLDataType.VARCHAR(20), this, "");

    /**
     * The column <code>public.messages.date</code>.
     */
    public final TableField<MessagesRecord, LocalDateTime> DATE = createField(DSL.name("date"), SQLDataType.LOCALDATETIME(6), this, "");

    /**
     * The column <code>public.messages.status</code>.
     */
    public final TableField<MessagesRecord, String> STATUS = createField(DSL.name("status"), SQLDataType.VARCHAR(10), this, "");

    /**
     * The column <code>public.messages.id</code>.
     */
    public final TableField<MessagesRecord, Integer> ID = createField(DSL.name("id"), SQLDataType.INTEGER.nullable(false).identity(true), this, "");

    private Messages(Name alias, Table<MessagesRecord> aliased) {
        this(alias, aliased, (Field<?>[]) null, null);
    }

    private Messages(Name alias, Table<MessagesRecord> aliased, Field<?>[] parameters, Condition where) {
        super(alias, null, aliased, parameters, DSL.comment(""), TableOptions.table(), where);
    }

    /**
     * Create an aliased <code>public.messages</code> table reference
     */
    public Messages(String alias) {
        this(DSL.name(alias), MESSAGES);
    }

    /**
     * Create an aliased <code>public.messages</code> table reference
     */
    public Messages(Name alias) {
        this(alias, MESSAGES);
    }

    /**
     * Create a <code>public.messages</code> table reference
     */
    public Messages() {
        this(DSL.name("messages"), null);
    }

    public <O extends Record> Messages(Table<O> path, ForeignKey<O, MessagesRecord> childPath, InverseForeignKey<O, MessagesRecord> parentPath) {
        super(path, childPath, parentPath, MESSAGES);
    }

    /**
     * A subtype implementing {@link Path} for simplified path-based joins.
     */
    public static class MessagesPath extends Messages implements Path<MessagesRecord> {
        public <O extends Record> MessagesPath(Table<O> path, ForeignKey<O, MessagesRecord> childPath, InverseForeignKey<O, MessagesRecord> parentPath) {
            super(path, childPath, parentPath);
        }
        private MessagesPath(Name alias, Table<MessagesRecord> aliased) {
            super(alias, aliased);
        }

        @Override
        public MessagesPath as(String alias) {
            return new MessagesPath(DSL.name(alias), this);
        }

        @Override
        public MessagesPath as(Name alias) {
            return new MessagesPath(alias, this);
        }

        @Override
        public MessagesPath as(Table<?> alias) {
            return new MessagesPath(alias.getQualifiedName(), this);
        }
    }

    @Override
    public Schema getSchema() {
        return aliased() ? null : Public.PUBLIC;
    }

    @Override
    public Identity<MessagesRecord, Integer> getIdentity() {
        return (Identity<MessagesRecord, Integer>) super.getIdentity();
    }

    @Override
    public UniqueKey<MessagesRecord> getPrimaryKey() {
        return Keys.MESSAGES_PKEY;
    }

    @Override
    public List<ForeignKey<MessagesRecord, ?>> getReferences() {
        return Arrays.asList(Keys.MESSAGES__FK_USER);
    }

    private transient UsersPath _users;

    /**
     * Get the implicit join path to the <code>public.users</code> table.
     */
    public UsersPath users() {
        if (_users == null)
            _users = new UsersPath(this, Keys.MESSAGES__FK_USER, null);

        return _users;
    }

    @Override
    public Messages as(String alias) {
        return new Messages(DSL.name(alias), this);
    }

    @Override
    public Messages as(Name alias) {
        return new Messages(alias, this);
    }

    @Override
    public Messages as(Table<?> alias) {
        return new Messages(alias.getQualifiedName(), this);
    }

    /**
     * Rename this table
     */
    @Override
    public Messages rename(String name) {
        return new Messages(DSL.name(name), null);
    }

    /**
     * Rename this table
     */
    @Override
    public Messages rename(Name name) {
        return new Messages(name, null);
    }

    /**
     * Rename this table
     */
    @Override
    public Messages rename(Table<?> name) {
        return new Messages(name.getQualifiedName(), null);
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Messages where(Condition condition) {
        return new Messages(getQualifiedName(), aliased() ? this : null, null, condition);
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Messages where(Collection<? extends Condition> conditions) {
        return where(DSL.and(conditions));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Messages where(Condition... conditions) {
        return where(DSL.and(conditions));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Messages where(Field<Boolean> condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Messages where(SQL condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Messages where(@Stringly.SQL String condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Messages where(@Stringly.SQL String condition, Object... binds) {
        return where(DSL.condition(condition, binds));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Messages where(@Stringly.SQL String condition, QueryPart... parts) {
        return where(DSL.condition(condition, parts));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Messages whereExists(Select<?> select) {
        return where(DSL.exists(select));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Messages whereNotExists(Select<?> select) {
        return where(DSL.notExists(select));
    }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\db\tables\records\MessagesRecord.java

/*
 * This file is generated by jOOQ.
 */
package org.zwierzchowski.marcin.db.tables.records;


import java.time.LocalDateTime;

import org.jooq.Record1;
import org.jooq.impl.UpdatableRecordImpl;
import org.zwierzchowski.marcin.db.tables.Messages;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class MessagesRecord extends UpdatableRecordImpl<MessagesRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * Setter for <code>public.messages.user_id</code>.
     */
    public void setUserId(Integer value) {
        set(0, value);
    }

    /**
     * Getter for <code>public.messages.user_id</code>.
     */
    public Integer getUserId() {
        return (Integer) get(0);
    }

    /**
     * Setter for <code>public.messages.content</code>.
     */
    public void setContent(String value) {
        set(1, value);
    }

    /**
     * Getter for <code>public.messages.content</code>.
     */
    public String getContent() {
        return (String) get(1);
    }

    /**
     * Setter for <code>public.messages.sender</code>.
     */
    public void setSender(String value) {
        set(2, value);
    }

    /**
     * Getter for <code>public.messages.sender</code>.
     */
    public String getSender() {
        return (String) get(2);
    }

    /**
     * Setter for <code>public.messages.date</code>.
     */
    public void setDate(LocalDateTime value) {
        set(3, value);
    }

    /**
     * Getter for <code>public.messages.date</code>.
     */
    public LocalDateTime getDate() {
        return (LocalDateTime) get(3);
    }

    /**
     * Setter for <code>public.messages.status</code>.
     */
    public void setStatus(String value) {
        set(4, value);
    }

    /**
     * Getter for <code>public.messages.status</code>.
     */
    public String getStatus() {
        return (String) get(4);
    }

    /**
     * Setter for <code>public.messages.id</code>.
     */
    public void setId(Integer value) {
        set(5, value);
    }

    /**
     * Getter for <code>public.messages.id</code>.
     */
    public Integer getId() {
        return (Integer) get(5);
    }

    // -------------------------------------------------------------------------
    // Primary key information
    // -------------------------------------------------------------------------

    @Override
    public Record1<Integer> key() {
        return (Record1) super.key();
    }

    // -------------------------------------------------------------------------
    // Constructors
    // -------------------------------------------------------------------------

    /**
     * Create a detached MessagesRecord
     */
    public MessagesRecord() {
        super(Messages.MESSAGES);
    }

    /**
     * Create a detached, initialised MessagesRecord
     */
    public MessagesRecord(Integer userId, String content, String sender, LocalDateTime date, String status, Integer id) {
        super(Messages.MESSAGES);

        setUserId(userId);
        setContent(content);
        setSender(sender);
        setDate(date);
        setStatus(status);
        setId(id);
        resetChangedOnNotNull();
    }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\db\tables\records\UsersRecord.java

/*
 * This file is generated by jOOQ.
 */
package org.zwierzchowski.marcin.db.tables.records;


import org.jooq.Record1;
import org.jooq.impl.UpdatableRecordImpl;
import org.zwierzchowski.marcin.db.tables.Users;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class UsersRecord extends UpdatableRecordImpl<UsersRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * Setter for <code>public.users.username</code>.
     */
    public void setUsername(String value) {
        set(0, value);
    }

    /**
     * Getter for <code>public.users.username</code>.
     */
    public String getUsername() {
        return (String) get(0);
    }

    /**
     * Setter for <code>public.users.password</code>.
     */
    public void setPassword(String value) {
        set(1, value);
    }

    /**
     * Getter for <code>public.users.password</code>.
     */
    public String getPassword() {
        return (String) get(1);
    }

    /**
     * Setter for <code>public.users.role</code>.
     */
    public void setRole(String value) {
        set(2, value);
    }

    /**
     * Getter for <code>public.users.role</code>.
     */
    public String getRole() {
        return (String) get(2);
    }

    /**
     * Setter for <code>public.users.id</code>.
     */
    public void setId(Integer value) {
        set(3, value);
    }

    /**
     * Getter for <code>public.users.id</code>.
     */
    public Integer getId() {
        return (Integer) get(3);
    }

    // -------------------------------------------------------------------------
    // Primary key information
    // -------------------------------------------------------------------------

    @Override
    public Record1<Integer> key() {
        return (Record1) super.key();
    }

    // -------------------------------------------------------------------------
    // Constructors
    // -------------------------------------------------------------------------

    /**
     * Create a detached UsersRecord
     */
    public UsersRecord() {
        super(Users.USERS);
    }

    /**
     * Create a detached, initialised UsersRecord
     */
    public UsersRecord(String username, String password, String role, Integer id) {
        super(Users.USERS);

        setUsername(username);
        setPassword(password);
        setRole(role);
        setId(id);
        resetChangedOnNotNull();
    }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\db\tables\Users.java

/*
 * This file is generated by jOOQ.
 */
package org.zwierzchowski.marcin.db.tables;


import java.util.Collection;

import org.jooq.Condition;
import org.jooq.Field;
import org.jooq.ForeignKey;
import org.jooq.Identity;
import org.jooq.InverseForeignKey;
import org.jooq.Name;
import org.jooq.Path;
import org.jooq.PlainSQL;
import org.jooq.QueryPart;
import org.jooq.Record;
import org.jooq.SQL;
import org.jooq.Schema;
import org.jooq.Select;
import org.jooq.Stringly;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.TableOptions;
import org.jooq.UniqueKey;
import org.jooq.impl.DSL;
import org.jooq.impl.SQLDataType;
import org.jooq.impl.TableImpl;
import org.zwierzchowski.marcin.db.Keys;
import org.zwierzchowski.marcin.db.Public;
import org.zwierzchowski.marcin.db.tables.Messages.MessagesPath;
import org.zwierzchowski.marcin.db.tables.records.UsersRecord;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class Users extends TableImpl<UsersRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>public.users</code>
     */
    public static final Users USERS = new Users();

    /**
     * The class holding records for this type
     */
    @Override
    public Class<UsersRecord> getRecordType() {
        return UsersRecord.class;
    }

    /**
     * The column <code>public.users.username</code>.
     */
    public final TableField<UsersRecord, String> USERNAME = createField(DSL.name("username"), SQLDataType.VARCHAR(20), this, "");

    /**
     * The column <code>public.users.password</code>.
     */
    public final TableField<UsersRecord, String> PASSWORD = createField(DSL.name("password"), SQLDataType.VARCHAR(100), this, "");

    /**
     * The column <code>public.users.role</code>.
     */
    public final TableField<UsersRecord, String> ROLE = createField(DSL.name("role"), SQLDataType.VARCHAR(10), this, "");

    /**
     * The column <code>public.users.id</code>.
     */
    public final TableField<UsersRecord, Integer> ID = createField(DSL.name("id"), SQLDataType.INTEGER.nullable(false).identity(true), this, "");

    private Users(Name alias, Table<UsersRecord> aliased) {
        this(alias, aliased, (Field<?>[]) null, null);
    }

    private Users(Name alias, Table<UsersRecord> aliased, Field<?>[] parameters, Condition where) {
        super(alias, null, aliased, parameters, DSL.comment(""), TableOptions.table(), where);
    }

    /**
     * Create an aliased <code>public.users</code> table reference
     */
    public Users(String alias) {
        this(DSL.name(alias), USERS);
    }

    /**
     * Create an aliased <code>public.users</code> table reference
     */
    public Users(Name alias) {
        this(alias, USERS);
    }

    /**
     * Create a <code>public.users</code> table reference
     */
    public Users() {
        this(DSL.name("users"), null);
    }

    public <O extends Record> Users(Table<O> path, ForeignKey<O, UsersRecord> childPath, InverseForeignKey<O, UsersRecord> parentPath) {
        super(path, childPath, parentPath, USERS);
    }

    /**
     * A subtype implementing {@link Path} for simplified path-based joins.
     */
    public static class UsersPath extends Users implements Path<UsersRecord> {
        public <O extends Record> UsersPath(Table<O> path, ForeignKey<O, UsersRecord> childPath, InverseForeignKey<O, UsersRecord> parentPath) {
            super(path, childPath, parentPath);
        }
        private UsersPath(Name alias, Table<UsersRecord> aliased) {
            super(alias, aliased);
        }

        @Override
        public UsersPath as(String alias) {
            return new UsersPath(DSL.name(alias), this);
        }

        @Override
        public UsersPath as(Name alias) {
            return new UsersPath(alias, this);
        }

        @Override
        public UsersPath as(Table<?> alias) {
            return new UsersPath(alias.getQualifiedName(), this);
        }
    }

    @Override
    public Schema getSchema() {
        return aliased() ? null : Public.PUBLIC;
    }

    @Override
    public Identity<UsersRecord, Integer> getIdentity() {
        return (Identity<UsersRecord, Integer>) super.getIdentity();
    }

    @Override
    public UniqueKey<UsersRecord> getPrimaryKey() {
        return Keys.USERS_PKEY;
    }

    private transient MessagesPath _messages;

    /**
     * Get the implicit to-many join path to the <code>public.messages</code>
     * table
     */
    public MessagesPath messages() {
        if (_messages == null)
            _messages = new MessagesPath(this, null, Keys.MESSAGES__FK_USER.getInverseKey());

        return _messages;
    }

    @Override
    public Users as(String alias) {
        return new Users(DSL.name(alias), this);
    }

    @Override
    public Users as(Name alias) {
        return new Users(alias, this);
    }

    @Override
    public Users as(Table<?> alias) {
        return new Users(alias.getQualifiedName(), this);
    }

    /**
     * Rename this table
     */
    @Override
    public Users rename(String name) {
        return new Users(DSL.name(name), null);
    }

    /**
     * Rename this table
     */
    @Override
    public Users rename(Name name) {
        return new Users(name, null);
    }

    /**
     * Rename this table
     */
    @Override
    public Users rename(Table<?> name) {
        return new Users(name.getQualifiedName(), null);
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Users where(Condition condition) {
        return new Users(getQualifiedName(), aliased() ? this : null, null, condition);
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Users where(Collection<? extends Condition> conditions) {
        return where(DSL.and(conditions));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Users where(Condition... conditions) {
        return where(DSL.and(conditions));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Users where(Field<Boolean> condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Users where(SQL condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Users where(@Stringly.SQL String condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Users where(@Stringly.SQL String condition, Object... binds) {
        return where(DSL.condition(condition, binds));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Users where(@Stringly.SQL String condition, QueryPart... parts) {
        return where(DSL.condition(condition, parts));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Users whereExists(Select<?> select) {
        return where(DSL.exists(select));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Users whereNotExists(Select<?> select) {
        return where(DSL.notExists(select));
    }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\db\Tables.java

/*
 * This file is generated by jOOQ.
 */
package org.zwierzchowski.marcin.db;


import org.zwierzchowski.marcin.db.tables.Messages;
import org.zwierzchowski.marcin.db.tables.Users;


/**
 * Convenience access to all tables in public.
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class Tables {

    /**
     * The table <code>public.messages</code>.
     */
    public static final Messages MESSAGES = Messages.MESSAGES;

    /**
     * The table <code>public.users</code>.
     */
    public static final Users USERS = Users.USERS;
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\exception\DatabaseConnectionException.java

package org.zwierzchowski.marcin.exception;

public class DatabaseConnectionException extends Exception {

  public DatabaseConnectionException(String message) {
    super(message);
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\exception\InvalidCredentialsFormatException.java

package org.zwierzchowski.marcin.exception;

public class InvalidCredentialsFormatException extends Exception {
    public InvalidCredentialsFormatException(String message) {
        super(message);
    }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\exception\InvalidMessageException.java

package org.zwierzchowski.marcin.exception;

public class InvalidMessageException extends Exception {
    public InvalidMessageException(String message) {
        super(message);
    }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\exception\InvalidPasswordException.java

package org.zwierzchowski.marcin.exception;

public class InvalidPasswordException extends Exception {

  public InvalidPasswordException(String message) {
    super(message);
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\exception\UserInboxIsFullException.java

package org.zwierzchowski.marcin.exception;

public class UserInboxIsFullException extends Exception {
  private String username;

  public UserInboxIsFullException(String message, String username) {
    super(message);
    this.username = username;
  }

  @Override
  public String getMessage() {
    return "Recipient '" + username + "' inbox is full";
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\exception\UserNotFoundException.java

package org.zwierzchowski.marcin.exception;

public class UserNotFoundException extends Exception {
    private String username;

    public UserNotFoundException(String message, String username) {
        super(message);
        this.username = username;
    }

    @Override
    public String getMessage() {
        return "User '" + username + "' not found";
    }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\message\Message.java

package org.zwierzchowski.marcin.message;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import java.time.LocalDateTime;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class Message {

  private int id;
  private String content;
  private String sender;
  private LocalDateTime createdDate;
  @JsonIgnore
  private Status status;

  public Message(String content, String sender) {
    this.content = content;
    this.sender = sender;
    this.createdDate = LocalDateTime.now();
    this.status = Status.UNREAD;
  }

  public Message(int id, String content, String sender, LocalDateTime date, Status status) {
    this.id = id;
    this.content = content;
    this.sender = sender;
    this.createdDate = date;
    this.status = status;
  }

  public enum Status {
    READ,
    UNREAD
  }

  @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm:ss")
  public LocalDateTime getCreatedDate() {
    return createdDate;
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\message\MessageRepository.java

package org.zwierzchowski.marcin.message;

import java.sql.Connection;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import org.jooq.DSLContext;
import org.jooq.Record;
import org.jooq.Result;
import org.jooq.SQLDialect;
import org.jooq.impl.DSL;
import org.zwierzchowski.marcin.db.tables.Messages;
import org.zwierzchowski.marcin.exception.DatabaseConnectionException;
import org.zwierzchowski.marcin.utils.DataBaseManager;

public class MessageRepository {

  DSLContext context;
  DataBaseManager dataBaseManager;

  public MessageRepository() throws DatabaseConnectionException {
    dataBaseManager = new DataBaseManager();
    Connection conn = dataBaseManager.getConnection();
    context = DSL.using(conn, SQLDialect.POSTGRES);
  }

  public void saveMessage(Message message, int userId) {
    context
        .insertInto(Messages.MESSAGES)
        .set(Messages.MESSAGES.CONTENT, message.getContent())
        .set(Messages.MESSAGES.SENDER, message.getSender())
        .set(Messages.MESSAGES.USER_ID, userId)
        .set(Messages.MESSAGES.DATE, message.getCreatedDate())
        .set(Messages.MESSAGES.STATUS, message.getStatus().toString())
        .execute();
  }

  public List<Message> findMessagesByUserId(int id) {

    Result<Record> messages =
        context.select().from(Messages.MESSAGES).where(Messages.MESSAGES.USER_ID.eq(id)).fetch();

    List<Message> messageList = new ArrayList<>();

    for (Record message : messages) {
      int messageId = message.getValue(Messages.MESSAGES.ID, Integer.class);
      String content = message.getValue(Messages.MESSAGES.CONTENT, String.class);
      String sender = message.getValue(Messages.MESSAGES.SENDER, String.class);
      String status = message.getValue(Messages.MESSAGES.STATUS, String.class);
      LocalDateTime date = message.getValue(Messages.MESSAGES.DATE, LocalDateTime.class);
      Message newMessage = new Message(messageId, content, sender, date, Message.Status.valueOf(status));
      messageList.add(newMessage);
    }
    return messageList;
  }

  public void updateMessage(int id) {

    context.update(Messages.MESSAGES)
        .set(Messages.MESSAGES.STATUS, Message.Status.READ.toString())
        .where(Messages.MESSAGES.ID.eq(id))
        .execute();
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\message\MessageService.java

package org.zwierzchowski.marcin.message;

import java.util.ArrayList;
import java.util.List;

import org.zwierzchowski.marcin.exception.DatabaseConnectionException;
import org.zwierzchowski.marcin.exception.UserInboxIsFullException;
import org.zwierzchowski.marcin.exception.UserNotFoundException;
import org.zwierzchowski.marcin.user.User;
import org.zwierzchowski.marcin.user.UserDataService;

public class MessageService {

  MessageRepository messageRepository;
  UserDataService userDataService;

  public MessageService() throws DatabaseConnectionException {
    messageRepository = new MessageRepository();
    userDataService = new UserDataService();
  }

  public void sendMessage(String recipient, String content, String sender)
      throws UserNotFoundException, UserInboxIsFullException {
    Message message = new Message(content, sender);

    User user = userDataService.getUser(recipient);

    if (user.isUserInboxFull()) {
      throw new UserInboxIsFullException("Recipient inbox is full", recipient);
    }
    messageRepository.saveMessage(message, user.getId());
  }

  public List<Message> getUnreadMessages(String username)
      throws UserNotFoundException {

    User user = userDataService.getUser(username);
    List<Message> messages = user.getMessages();
    List<Message> unreadMessages = new ArrayList<>();
    if (!messages.isEmpty()) {
      for (Message m : messages) {
        if (m.getStatus().equals(Message.Status.UNREAD)) {
          unreadMessages.add(m);
          m.setStatus(Message.Status.READ);
          messageRepository.updateMessage(m.getId());
        }
      }
    }
    return unreadMessages;
  }

  public List<Message> getAllMessages(String username) throws UserNotFoundException {

    User user = userDataService.getUser(username);
    List<Message> messages = user.getMessages();

    return messages;
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\server\Server.java

package org.zwierzchowski.marcin.server;

import java.io.IOException;
import java.net.ServerSocket;
import lombok.extern.log4j.Log4j2;
import org.zwierzchowski.marcin.exception.DatabaseConnectionException;

@Log4j2
public class Server {

  private ServerSocket serverSocket;
  private ServerData serverData;
  private ServerCommandService serverCommandService;
  private Session session = new Session();
  private ServerNetworkHandler serverNetworkHandler;

  public Server(int port) {
    try {
      serverSocket = new ServerSocket(port);
      serverData = new ServerData();
      serverNetworkHandler = new ServerNetworkHandler(serverSocket);
      serverCommandService = new ServerCommandService(serverNetworkHandler, session, serverData);
      log.info("Server started on port {}", port);
    } catch (IOException | DatabaseConnectionException e) {
      log.error("Error creating server", e);
      log.info("Application is shutting down...");
      System.exit(1);
    }
  }

  public static void main(String[] args) {
    Server server = new Server(6666);
    server.start();
  }

  public void start() {
    try {
      serverNetworkHandler.acceptConnection();
    } catch (IOException e) {
      log.error("Failed to connect client", e);
      System.exit(1);
    }
    handleClient();
  }

  private void handleClient() {
    try {
      String clientRequest;
      serverNetworkHandler.sendMessage(serverCommandService.printOptions());

      while ((clientRequest = serverNetworkHandler.receiveMessage()) != null) {
        log.info("Client request: {}", clientRequest);

        String serverResponse = serverCommandService.handleRequest(clientRequest);
        if ("STOP_SERVER".equals(serverResponse)) {
          break;
        }
        serverNetworkHandler.sendMessage(serverResponse);
        serverNetworkHandler.sendMessage(serverCommandService.printOptions());
      }
    } catch (IOException e) {
      log.error("Error handling client", e);
    } finally {
      serverNetworkHandler.close();
    }
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\server\ServerCommandService.java

package org.zwierzchowski.marcin.server;

import static org.zwierzchowski.marcin.server.ServerCommandService.Command.*;

import com.fasterxml.jackson.core.JsonProcessingException;
import java.io.IOException;
import java.util.List;
import lombok.extern.log4j.Log4j2;
import org.zwierzchowski.marcin.exception.*;
import org.zwierzchowski.marcin.message.Message;
import org.zwierzchowski.marcin.message.MessageService;
import org.zwierzchowski.marcin.user.User;
import org.zwierzchowski.marcin.user.UserDataService;
import org.zwierzchowski.marcin.user.dto.UserLoginDTO;
import org.zwierzchowski.marcin.user.dto.UserRegistrationDTO;
import org.zwierzchowski.marcin.utils.CredentialsValidator;
import org.zwierzchowski.marcin.utils.MessageValidator;

@Log4j2
public class ServerCommandService {

  private UserDataService userDataService;
  private MessageService messageService;
  private ServerResponse response;
  private ServerNetworkHandler serverNetworkHandler;
  private Session session;
  private ServerData serverData;

  public ServerCommandService(
      ServerNetworkHandler serverNetworkHandler, Session session, ServerData serverData) throws DatabaseConnectionException {
    this.serverNetworkHandler = serverNetworkHandler;
    this.session = session;
    this.serverData = serverData;
    this.response = new ServerResponse();
    this.userDataService = new UserDataService();
    this.messageService = new MessageService();
  }

  public String handleRequest(String clientRequest) throws JsonProcessingException {

    Command command = fromString(clientRequest);
    try {
      return switch (command) {
        case REGISTER -> handleRegistration();
        case LOGIN -> handleUserLogin();
        case LOGOUT -> handleUserLogout();
        case DELETE_USER -> handleUserDelete();
        case SEND -> handleSendMessage();
        case READ_ALL -> handleReadAllMessages();
        case READ_UNREAD -> handleReadUnreadMessages();
        case STOP -> handleStopServer();
        case UPTIME -> response.calculateUptime(serverData.getStartTime());
        case HELP -> response.printServerCommands(serverData.getCommandsInfo());
        case INFO -> response.printServerInfo(serverData.getSeverInfo());
        case UNKNOWN -> response.printText("Command unknown");
      };
    } catch (Exception e) {
      return handleException(e);
    }
  }

  private String handleRegistration() throws IOException, InvalidCredentialsFormatException {

    UserRegistrationDTO userDto = requestRegistrationData();
    validateUserRegistrationData(userDto);

    User user =
        userDataService.addUser(userDto.getUsername(), userDto.getPassword(), userDto.getRole());

    return response.printText("User: " + user.getUsername() + " successfully registered");
  }

  private UserRegistrationDTO requestRegistrationData() throws IOException {
    serverNetworkHandler.sendMessage(response.printText("Please provide username"));
    String username = serverNetworkHandler.receiveMessage();

    serverNetworkHandler.sendMessage(response.printText("Please provide password"));
    String password = serverNetworkHandler.receiveMessage();

    serverNetworkHandler.sendMessage(response.printText("Please provide user role"));
    String role = serverNetworkHandler.receiveMessage();

    return new UserRegistrationDTO(username, password, role);
  }

  private void validateUserRegistrationData(UserRegistrationDTO user)
      throws InvalidCredentialsFormatException {
    CredentialsValidator.validateUsername(user.getUsername());
    CredentialsValidator.validatePassword(user.getPassword());
    CredentialsValidator.validateRole(user.getRole());
  }

  private String handleUserLogin()
      throws IOException,
          UserNotFoundException,
          InvalidPasswordException,
          IllegalArgumentException {

    UserLoginDTO userDto = requestLoginData();
    userDataService.isValidCredentials(userDto.getUsername(), userDto.getPassword());
    User user = userDataService.getUser(userDto.getUsername());
    session.setLoggedInUser(user);
    return response.printLoginStatus(true);
  }

  private UserLoginDTO requestLoginData() throws IOException {
    serverNetworkHandler.sendMessage(response.printText("Please provide username"));
    String username = serverNetworkHandler.receiveMessage();

    serverNetworkHandler.sendMessage(response.printText("Please provide password"));
    String password = serverNetworkHandler.receiveMessage();

    return new UserLoginDTO(username, password);
  }

  private String handleStopServer() throws JsonProcessingException {
    serverNetworkHandler.sendMessage(response.printText("Shutting down server"));
    return "STOP_SERVER";
  }

  private String handleUserLogout() throws JsonProcessingException {
    if (!session.isUserLoggedIn()) {
      return response.printText("No user logged in");
    }
    session.logoutUser();
    return response.printText("Logout successful");
  }

  private String handleUserDelete() throws IOException, UserNotFoundException {

    if (!session.isAdminLoggedIn()) {
      return response.printText("Admin privileges are required to delete a user.");
    }
    serverNetworkHandler.sendMessage(response.printText("Please provide username"));
    String username = serverNetworkHandler.receiveMessage();

    userDataService.deleteUser(username);
    return response.printText("User successfully deleted");
  }

  private String handleSendMessage()
      throws IOException, InvalidMessageException, UserNotFoundException, UserInboxIsFullException {

    if (!session.isUserLoggedIn()) {
      return response.printText("User needs to log in");
    }
    serverNetworkHandler.sendMessage(response.printText("Please provide recipient"));
    String recipient = serverNetworkHandler.receiveMessage();

    serverNetworkHandler.sendMessage(response.printText("Please provide  message"));
    String content = serverNetworkHandler.receiveMessage();

    MessageValidator.validateMessage(content);
    String sender = session.getLoggedInUser().getUsername();
    messageService.sendMessage(recipient, content, sender);
    return response.printText("Message to send successfully");
  }

  private String handleReadAllMessages() throws IOException, UserNotFoundException {

    if (!session.isUserLoggedIn()) {
      return response.printText("User needs to log in");
    }
    User user = session.getLoggedInUser();
    List<Message> messages = messageService.getAllMessages(user.getUsername());
    if (messages.isEmpty()) {
      return response.printText("No messages");
    }
    return response.printUnreadMessages(messages);
  }

  private String handleReadUnreadMessages() throws IOException, UserNotFoundException {

    if (!session.isUserLoggedIn()) {
      return response.printText("User needs to log in");
    }
    User user = session.getLoggedInUser();
    List<Message> messages = messageService.getUnreadMessages(user.getUsername());
    if (messages.isEmpty()) {
      return response.printText("No messages");
    }
    return response.printUnreadMessages(messages);
  }

  public String printOptions() throws JsonProcessingException {
    if (session.isUserLoggedIn()) {
      return printUserOptions();
    } else if (session.isAdminLoggedIn()) {
      return printAdminOptions();
    } else return printWelcomeOptions();
  }

  private String printWelcomeOptions() throws JsonProcessingException {

    return response.printText("Type command: " + "LOGIN," + "REGISTER.");
  }

  private String printAdminOptions() throws JsonProcessingException {
    String options =
        "Type command: "
            + "SEND, "
            + "READ_ALL, "
            + "READ_UNREAD, "
            + "UPDATE_USER, "
            + "DELETE_USER, "
            + "HELP, "
            + "LOGOUT.";
    return response.printText(options);
  }

  private String printUserOptions() throws JsonProcessingException {
    String options =
        "Type command: " + "SEND, " + "READ_ALL, " + "READ_UNREAD, " + "HELP, " + "LOGOUT.";
    return response.printText(options);
  }

  private String handleException(Exception e) throws JsonProcessingException {
    if (e instanceof JsonProcessingException) {
      log.error("JSON processing error", e);
      return response.printError(e.getMessage());
    } else if (e instanceof InvalidCredentialsFormatException) {
      log.error("Invalid Credentials format", e);
      return response.printError(e.getMessage());
    } else if (e instanceof UserNotFoundException || e instanceof InvalidPasswordException) {
      log.error("Invalid user credentials", e);
      return response.printError(e.getMessage());
    } else if (e instanceof UserInboxIsFullException) {
      log.error("User inbox is full", e);
      return response.printText("Message not send." + e.getMessage());
    } else if (e instanceof InvalidMessageException) {
      log.error("Invalid Message format", e);
      return response.printText("Invalid message: " + e.getMessage());
    } else if (e instanceof IOException) {
      log.error("Error while communicating with server", e);
      return response.printText("Error while communicating with server: " + e.getMessage());
    } else {
      log.error("Unexpected error", e);
      return response.printText("Unexpected error: " + e.getMessage());
    }
  }

  public enum Command {
    REGISTER,
    LOGIN,
    LOGOUT,
    DELETE_USER,
    SEND,
    READ_ALL,
    READ_UNREAD,
    UPTIME,
    HELP,
    INFO,
    STOP,
    UNKNOWN;

    public static Command fromString(String command) {
      try {
        return Command.valueOf(command.toUpperCase());
      } catch (IllegalArgumentException e) {
        return UNKNOWN;
      }
    }
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\server\ServerData.java

package org.zwierzchowski.marcin.server;

import lombok.Getter;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

@Getter
public class ServerData {

  private final Map<String, String> commandsInfo = new HashMap<>();
  private final Map<String, String> severInfo = new HashMap<>();
  private static final String SERVER_VERSION = "0.2.0";
  private static final String SERVER_CREATION_DATE = "19.04.2024";
  private Instant startTime;

  public ServerData() {
    initialize();
  }

  private void initialize() {
    commandsInfo.put("uptime", "Returns the server's uptime");
    commandsInfo.put("info", "Returns the server's version number and creation date");
    commandsInfo.put("help", "Returns a list of available commands with a brief description");
    commandsInfo.put("stop", "stops both the server and the client simultaneously");
    commandsInfo.put("register", "Add new user");
    commandsInfo.put("login", "Login existing user");
    commandsInfo.put("logout", "Logout user");
    commandsInfo.put("delete", "Delete existing user. Required admin role");
    commandsInfo.put("send", "Send message to another user");
    commandsInfo.put("read", "Read unread messages in inbox");

    severInfo.put("version", SERVER_VERSION);
    severInfo.put("creation date", SERVER_CREATION_DATE);

    startTime = Instant.now();
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\server\ServerNetworkHandler.java

package org.zwierzchowski.marcin.server;

import lombok.extern.log4j.Log4j2;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

@Log4j2
public class ServerNetworkHandler {

  private Socket clientSocket;
  private BufferedReader in;
  private PrintWriter out;
  private ServerSocket serverSocket;

  public ServerNetworkHandler(ServerSocket serverSocket) {
    this.serverSocket = serverSocket;
  }

  public void acceptConnection() throws IOException {

    log.info("Waiting for a client...");
    clientSocket = serverSocket.accept();
    in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
    out = new PrintWriter(clientSocket.getOutputStream(), true);
    log.info("Client connected");
  }

  public String receiveMessage() throws IOException {
    return in.readLine();
  }

  public void sendMessage(String message) {
    out.println(message);
  }

  public void close() {
    closeClientConnection();
    closeServerSocket();
  }

  private void closeClientConnection() {
    log.info("Closing client connection...");
    try {
      if (out != null) {
        out.close();
      }
      if (in != null) {
        in.close();
      }
      if (clientSocket != null && !clientSocket.isClosed()) {
        clientSocket.close();
      }
    } catch (IOException e) {
      log.error("Failed to close client connection resources: {}", e.getMessage());
    }
  }

  private void closeServerSocket() {
    log.info("Closing server socket...");
    try {
      if (serverSocket != null && !serverSocket.isClosed()) {
        serverSocket.close();
      }
    } catch (IOException e) {
      log.error("Error closing server socket: {}", e.getMessage());
    }
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\server\ServerResponse.java

package org.zwierzchowski.marcin.server;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.zwierzchowski.marcin.message.Message;

public class ServerResponse {

  private final ObjectMapper mapper = new ObjectMapper().registerModule(new JavaTimeModule());

  public String calculateUptime(Instant startTime) throws JsonProcessingException {
    Duration serverUptime = Duration.between(startTime, Instant.now());
    Map<String, Integer> uptimeResponse = new HashMap<>();
    uptimeResponse.put("hours", serverUptime.toHoursPart());
    uptimeResponse.put("minutes", serverUptime.toMinutesPart());
    uptimeResponse.put("seconds", serverUptime.toSecondsPart());
    return mapper.writeValueAsString(uptimeResponse);
  }

  public String printServerCommands(Map<String, String> commandsInfo)
      throws JsonProcessingException {
    return mapper.writeValueAsString(commandsInfo);
  }

  public String printServerInfo(Map<String, String> serverInfo) throws JsonProcessingException {
    return mapper.writeValueAsString(serverInfo);
  }

  public String printText(String text) throws JsonProcessingException {
    return mapper.writeValueAsString(text);
  }

  public String printError(String text) throws JsonProcessingException {
    Map<String, String> message = new HashMap<>();
    message.put("error", text);
    return mapper.writeValueAsString(message);
  }

  public String printLoginStatus(boolean status) throws JsonProcessingException {
    Map<String, String> response = new HashMap<>();
    if (status) {
      response.put("status", "User sucessfully logged in");
    } else {
      response.put("status", "Incorrect username or password");
    }
    return mapper.writeValueAsString(response);
  }

  public String printUnreadMessages(List<Message> unreadMessages) throws JsonProcessingException {
    Map<String, Message> messagesResponse = new LinkedHashMap<>();
    for (int i = 0; i < unreadMessages.size(); i++) {
      Message m = unreadMessages.get(i);
      messagesResponse.put("Message " + (i + 1), m);
    }
    return mapper.writeValueAsString(messagesResponse);
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\server\Session.java

package org.zwierzchowski.marcin.server;

import lombok.Getter;
import lombok.Setter;
import org.zwierzchowski.marcin.user.User;

@Getter
@Setter
public class Session {

  private User loggedInUser;

  public boolean isUserLoggedIn() {
    return loggedInUser != null && !loggedInUser.getRole().equals(User.Role.ADMIN);
  }

  public boolean isAdminLoggedIn() {
    return loggedInUser != null && loggedInUser.getRole().equals(User.Role.ADMIN);
  }

  public void logoutUser() {
    loggedInUser = null;
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\user\Admin.java

package org.zwierzchowski.marcin.user;

import java.util.ArrayList;
import java.util.List;
import lombok.Getter;
import lombok.Setter;
import org.zwierzchowski.marcin.message.Message;

@Getter
@Setter
public class Admin extends User {


  public Admin(String username, String password) {
    super(username, password, Role.ADMIN, new ArrayList<>());
  }

  public Admin(int id, String username, String password,  List<Message> messages) {
    super(id, username, password, Role.ADMIN, messages);
  }

  @Override
  public boolean isUserInboxFull() {
    return false;
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\user\dto\UserLoginDTO.java

package org.zwierzchowski.marcin.user.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class UserLoginDTO {

      private String username;
      private String password;
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\user\dto\UserRegistrationDTO.java

package org.zwierzchowski.marcin.user.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class UserRegistrationDTO {

      private String username;
      private String password;
      private String role;
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\user\StandardUser.java

package org.zwierzchowski.marcin.user;

import java.util.ArrayList;
import java.util.List;
import lombok.Getter;
import lombok.Setter;
import org.zwierzchowski.marcin.message.Message;

@Getter
@Setter
public class StandardUser extends User {

  private static final int MAX_UNREAD_MESSAGES = 4;

  public StandardUser(String username, String password) {
    super(username, password, Role.USER, new ArrayList<>());
  }

  public StandardUser(int id,String username, String password, List<Message> messages) {
  super(id,username, password, Role.USER, messages);
  }

  @Override
  public boolean isUserInboxFull() {
    long countUnread =
        super.getMessages().stream()
            .filter(m -> m.getStatus().equals(Message.Status.UNREAD))
            .count();
    return countUnread > MAX_UNREAD_MESSAGES;
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\user\User.java

package org.zwierzchowski.marcin.user;


import java.util.List;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import org.zwierzchowski.marcin.message.Message;

@Getter
@Setter
@AllArgsConstructor
public abstract class User {

  private int id;
  private String username;
  private String password;
  private Role role;
  private List<Message> messages;

  protected User(String username, String password, Role role, List<Message> messages) {
    this.username = username;
    this.password = password;
    this.role = role;
    this.messages = messages;
  }

  public void addMessage(Message message) {
    messages.add(message);
  }

  public abstract boolean isUserInboxFull();

  public enum Role {
    USER,
    ADMIN
  }

  @Override
  public String toString() {
    return "User{" +
            "id=" + id +
            ", username='" + username + '\'' +
            ", password='" + password + '\'' +
            ", role=" + role +
            ", messages=" + messages +
            '}';
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\user\UserDataService.java

package org.zwierzchowski.marcin.user;

import java.util.List;
import org.mindrot.jbcrypt.BCrypt;
import org.zwierzchowski.marcin.exception.DatabaseConnectionException;
import org.zwierzchowski.marcin.exception.InvalidCredentialsFormatException;
import org.zwierzchowski.marcin.exception.InvalidPasswordException;
import org.zwierzchowski.marcin.exception.UserNotFoundException;
import org.zwierzchowski.marcin.message.Message;
import org.zwierzchowski.marcin.message.MessageRepository;

public class UserDataService {

  private UserRepository userRepository;
  private MessageRepository messageRepository;

  public UserDataService() throws DatabaseConnectionException {
    userRepository = new UserRepository();
    messageRepository = new MessageRepository();
  }

  public User addUser(String username, String password, String role)
      throws InvalidCredentialsFormatException {
    String hashedPassword = BCrypt.hashpw(password, BCrypt.gensalt());
    User newUser =
        switch (role.toLowerCase()) {
          case "user" -> new StandardUser(username, hashedPassword);
          case "admin" -> new Admin(username, hashedPassword);
          default -> throw new InvalidCredentialsFormatException("Unexpected value: " + role);
        };

    userRepository.saveUser(newUser);
    return newUser;
  }

  public boolean isValidCredentials(String username, String password)
      throws UserNotFoundException, InvalidPasswordException, IllegalArgumentException {

    User user = userRepository.findByUsername(username);
    if (user == null) {
      throw new UserNotFoundException("User not exist", username);
    }

    if (!BCrypt.checkpw(password, user.getPassword())) {
      throw new InvalidPasswordException("Invalid password");
    }

    return true;
  }

  public User getUser(String username) throws UserNotFoundException {

    User user = userRepository.findByUsername(username);
    List<Message> messages = messageRepository.findMessagesByUserId(user.getId());
    user.setMessages(messages);

    return user;
  }

  public void deleteUser(String username) throws UserNotFoundException {

    User user = userRepository.findByUsername(username);
    if (user == null) {
      throw new UserNotFoundException("User not exist", username);
    }
    userRepository.deleteUser(username);
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\user\UserRepository.java

package org.zwierzchowski.marcin.user;

import java.sql.Connection;
import org.jooq.DSLContext;
import org.jooq.Record;
import org.jooq.SQLDialect;
import org.jooq.impl.DSL;
import org.zwierzchowski.marcin.db.tables.Users;
import org.zwierzchowski.marcin.exception.DatabaseConnectionException;
import org.zwierzchowski.marcin.exception.UserNotFoundException;
import org.zwierzchowski.marcin.utils.DataBaseManager;

public class UserRepository {

  DSLContext context;
  DataBaseManager dataBaseManager;

  public UserRepository() throws DatabaseConnectionException {
    dataBaseManager = new DataBaseManager();
    Connection conn = dataBaseManager.getConnection();
    context = DSL.using(conn, SQLDialect.POSTGRES);
  }

  public void saveUser(User user) {
    context
        .insertInto(Users.USERS)
        .set(Users.USERS.USERNAME, user.getUsername())
        .set(Users.USERS.PASSWORD, user.getPassword())
        .set(Users.USERS.ROLE, String.valueOf(user.getRole()))
        .execute();
  }

  public User findByUsername(String username)
      throws UserNotFoundException {

    Record userRecord =
        context.select().from(Users.USERS).where(Users.USERS.USERNAME.eq(username)).fetchOne();

    if (userRecord == null) {
      throw new UserNotFoundException("User not exist", username);
    }

    String usernameDb = userRecord.getValue(Users.USERS.USERNAME, String.class);
    String password = userRecord.getValue(Users.USERS.PASSWORD, String.class);
    String role = userRecord.getValue(Users.USERS.ROLE, String.class);
    int id = userRecord.getValue(Users.USERS.ID, Integer.class);

    User user =
        switch (role.toLowerCase()) {
          case "user" -> new StandardUser(id, usernameDb, password, null);
          case "admin" -> new Admin(id, usernameDb, password, null);
          default -> throw new IllegalArgumentException("Unexpected value: " + role);
        };
    return user;
  }

  public void deleteUser(String username) {
    context.delete(Users.USERS).where(Users.USERS.USERNAME.eq(username)).execute();
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\utils\CredentialsValidator.java

package org.zwierzchowski.marcin.utils;

import org.zwierzchowski.marcin.exception.InvalidCredentialsFormatException;
import org.zwierzchowski.marcin.user.User;

import java.util.regex.Pattern;

public class CredentialsValidator {

  private static final String USERNAME_PATTERN = "^[A-Za-z][A-Za-z0-9]{1,28}$";
  private static final String PASSWORD_PATTERN = "^[A-Za-z]\\w{2,29}$";

  private CredentialsValidator() {}

  public static void validateUsername(String username) throws InvalidCredentialsFormatException {
    if (!Pattern.matches(USERNAME_PATTERN, username)) {
      throw new InvalidCredentialsFormatException("Invalid username format");
    }
  }

  public static void validatePassword(String password) throws InvalidCredentialsFormatException {
    if (!Pattern.matches(PASSWORD_PATTERN, password)) {
      throw new InvalidCredentialsFormatException("Invalid password format");
    }
  }

  public static void validateRole(String role) throws InvalidCredentialsFormatException {
    boolean isValidRole = false;
    for (User.Role r : User.Role.values()) {
      if (r.name().equalsIgnoreCase(role)) {
        isValidRole = true;
        break;
      }
    }
    if (!isValidRole) {
      throw new InvalidCredentialsFormatException("Invalid role");
    }
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\utils\DataBaseManager.java

package org.zwierzchowski.marcin.utils;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Properties;

import lombok.extern.log4j.Log4j2;
import org.jooq.tools.JooqLogger;
import org.zwierzchowski.marcin.exception.DatabaseConnectionException;

@Log4j2
public class DataBaseManager {

  String username;
  String password;
  String url;

  public DataBaseManager() {
    getCredentials();
  }

  public Connection getConnection() throws DatabaseConnectionException {
    JooqLogger.globalThreshold(org.jooq.tools.JooqLogger.Level.WARN);
    try {
        return DriverManager.getConnection(url, username, password);
    } catch (SQLException e) {
      log.error("Error connecting to database", e);
      throw new DatabaseConnectionException("Cannot connect to database");
    }
  }

  private void getCredentials() {

    Properties properties = new Properties();

    try {
      properties.load(DataBaseManager.class.getClassLoader().getResourceAsStream("db.properties"));
      username = properties.getProperty("username");
      password = properties.getProperty("password");
      url = properties.getProperty("url");
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\utils\DbGenerationTool.java

package org.zwierzchowski.marcin.utils;

import org.jooq.codegen.GenerationTool;

import java.nio.file.Files;
import java.nio.file.Path;

public class DbGenerationTool {

  public static void main(String[] args) throws Exception {
    GenerationTool.generate(
        Files.readString(
            Path.of(
                "C:\\Users\\marci\\IdeaProjects\\ZR\\client-server\\client-server\\src\\main\\resources\\jooq-config.xml")));
    }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\utils\FileService.java

package org.zwierzchowski.marcin.utils;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import org.zwierzchowski.marcin.user.User;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class FileService {

  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
  private static final String FILE_PATH = "./users.json";

  private FileService() {}

  public static Map<String, User> loadDataBase() throws IOException {
    File file = new File(FILE_PATH);
    if (file.exists() && file.length() != 0) {
      return OBJECT_MAPPER.readValue(file, new TypeReference<Map<String, User>>() {});
    } else {
      return new HashMap<>();
    }
  }

  public static void saveDataBase(Map<String, User> users) throws IOException {
    File file = new File(FILE_PATH);
    OBJECT_MAPPER.enable(SerializationFeature.INDENT_OUTPUT);
    OBJECT_MAPPER.writerFor(new TypeReference<Map<String, User>>() {}).writeValue(file, users);
  }
}
====================

====================
FILE: .\client-server\src\main\java\org\zwierzchowski\marcin\utils\MessageValidator.java

package org.zwierzchowski.marcin.utils;

import org.zwierzchowski.marcin.exception.InvalidMessageException;

public class MessageValidator {

  private static final int MESSAGE_LENGTH = 255;

  private MessageValidator() {}

  public static void validateMessage(String content) throws InvalidMessageException {
    if (content == null || content.length()  > MESSAGE_LENGTH || content.isEmpty()) {
      throw new InvalidMessageException("Invalid message format");
    }
  }
}
====================

